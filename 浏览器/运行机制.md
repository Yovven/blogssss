一.进程与线程
进程是CPU资源分配的最小单位，线程是CPU调度的最小单位。
一个进程可以包括多个线程，进程分为多线程和单线程。

二.浏览器是多进程。
当打开浏览器时，一般情况下会默认打开4个进程。
1.浏览器主进程（Broswer进程）。只有一个，负责管理页签的打开关闭、浏览器的界面操作、调度其他进程的运行、网络资源的管理和下载。
2.GPU进程。最多一个，用于3D绘制等。
3.插件进程。负责插件的运行工作，有多少插件就有多少进程，仅当使用该插件时才创建。
4.浏览器渲染进程（浏览器内核）Rendered。负责页面渲染，脚本执行，事件处理等，是最重要的一个进程。每打开一个tab都会新建一个渲染进程，进程之间互不影响。

三.浏览器渲染进程是多线程的，包括以下线程：
1.JS执行引擎线程：也称为JS内核，负责处理Javascript脚本程序。
2.GUI渲染线程：负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。
3.事件触发线程：负责管理事件循环。当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理。
4.定时器线程：管理定时器setTimeOut和setInterval。
5.异步任务线程：负责执行异步请求一类的函数的线程。

注意！！！GUI渲染线程和JS执行引擎线程是互斥的，即执行JS和解析DOM两者只能同时存在一件。原因是执行JS过程中可能会修改DOM，如果两者不互斥，那么页面会出现一些DOM被修改的变化过程，其次最终显示的JS执行之后的效果，因此前面的DOM解析和构建是一种资源浪费。

四.当打开浏览器并打开一个页面时：
1.主进程Broswer->渲染进程Render
Broswer进程通过http请求到页面所需的内容，通过特定的接口发送给Render进程。
2.渲染进程Render->GPU进程
Renderer进程的Renderer接口收到消息，简单解释后，交给渲染线程，然后开始渲染
首先是JS执行引擎线程和GUI渲染线程串行工作，渲染线程接收请求，加载网页并渲染网页，直至执行解析并构建好DOM树，这其中可能需要Browser进程获取资源和需要GPU进程来帮助渲染
在执行JS过程中，由于JS是单线程执行，因此执行过程产生的异步任务和回调事件会交给其他线程来管理。
当有计时器事件，会交给定时器线程负责定时，当定时时间到了，定时器线程会把回调函数交给事件触发线程，事件触发线程会把事件放入任务队列中。
当有异步任务时，会交给异步任务处理，当触发条件满足，会把回调函数交给事件触发线程，事件触发线程会把事件放入任务队列中。
事件触发线程负责接收回调任务，并且将这些任务维护在一个队列中，等待JS引擎执行。
3.渲染进程Render->主进程Broswer
Browser进程接收到结果并将结果绘制出来

五.GUI渲染线程


六.浏览器事件循环机制
JS在浏览器的执行引擎中是单线程的，它执行时遵循事件循环机制。
浏览器端事件循环中的异步队列有两种，分为别宏任务（macro-task）队列和微任务（micro-task）队列，执行引擎按照事件循环机制从这两中队列中取出任务并执行。其中，
宏任务包括：setTimeout、setInterval、script（整体代码）、requestAnimationFrame（浏览器独有）、 I/O 操作（network events(http等协议请求)用户交互事件(例如鼠标点击click事件、键盘输入keydown事件等)、文件相关操作）、UI 渲染、MessageChannel(通过接口提供的Port1和Port2来互相传递消息)。
微任务包括：new Promise().then(回调)、MutationObserver(html5新特性) 、Object.observe、process.nextTick(Node独有，调用顺序在Promise之前。
宏任务队列可以有多个，微任务队列只有一个。
一个事件循环过程：
a.在宏任务中取出一个宏任务压入执行栈并执行；执行完毕弹出执行栈；
b.查看微任务队列，如果队列中有任务，则会逐个执行队列中的任务并把它出队，直到队列被清空；在微任务执行过程中产生的新的微任务也会在此次循环中被执行。
c.执行渲染操作，更新界面
d.检查是否存在 Web worker 任务，如果有，则对其进行处理
e.从a开始一次新的循环。上述过程循环往复，直到两个队列都清空。

七.Node的事件循环
1.nodejs运行机制
Application -> V8引擎解析js -> 调用Node API -> libuv负责node api的执行，在这个过程中实现事件循环。
a.V8引擎解析javascript脚本。
b.解析完调用Node API。
c.libuv 负责Node API的执行，它将不同的任务分配给不同的线程，形成一个事件循环，以异步的方式将任务的执行结果返回给V8引擎。
d.V8引擎将结果返回给用户。

2.事件循环过程
libuv引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。
timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调
I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调
idle, prepare 阶段：仅node内部使用
poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里
check 阶段：执行 setImmediate() 的回调
close callbacks 阶段：执行 socket 的 close 事件回调

外部输入数据-->轮询阶段(poll)-->检查阶段(check)-->关闭事件回调阶段(close callback)-->定时器检测阶段(timer)-->I/O事件回调阶段(I/O callbacks)-->闲置阶段(idle, prepare)-->轮询阶段（按照该顺序反复运行）...

3.常用的三个阶段：
(1) timer
timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。
同样，在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行。
timers阶段有几个setTimeout/setInterval都会依次执行。
(2) poll
poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情：
  1.回到 timer 阶段执行回调；
  2.执行 I/O 回调
  并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情：
    1.如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制；
    2.如果 poll 队列为空时，会有两件事发生：
      1.如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调；
      2.如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去；
当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。
(3) check阶段
setImmediate()的回调会被加入check队列中。

4.setTimeout 和 setImmediate
二者非常相似，区别主要在于调用时机不同。
  setImmediate 设计在poll阶段完成时执行，即check阶段；
  setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行，但它在timer阶段执行

5.process.nextTick
这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。

6.Node与浏览器的 Event Loop 差异
浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。
而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。